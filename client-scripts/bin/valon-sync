#!/bin/bash
# valon-sync - Sync own endpoint and resolve peer endpoints
#
# Usage: valon-sync [--config /path/to/client.conf] [--peer <pubkey>]

set -e

# Configuration search order:
# 1. Environment variable: $VALON_CONFIG or $CONFIG_FILE
# 2. Command line argument: --config
# 3. Current directory: ./valon-sync.conf
# 4. User home: ~/.config/valon/client.conf
# 5. System: /etc/valon/client.conf
find_config() {
    local candidates=(
        "${VALON_CONFIG}"
        "${CONFIG_FILE}"
        "./valon-sync.conf"
        "${HOME}/.config/valon/client.conf"
        "/etc/valon/client.conf"
    )
    
    for conf in "${candidates[@]}"; do
        if [[ -n "$conf" && -f "$conf" ]]; then
            echo "$conf"
            return 0
        fi
    done
    return 1
}

# Default paths
CONFIG_FILE="$(find_config || true)"
TARGET_PEER=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        --peer)
            TARGET_PEER="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--config /path/to/client.conf] [--peer <pubkey>]"
            echo ""
            echo "Sync own LAN endpoint to Discovery and update peer endpoints"
            echo ""
            echo "Configuration search order:"
            echo "  1. \$VALON_CONFIG or \$CONFIG_FILE"
            echo "  2. --config argument"
            echo "  3. ./valon-sync.conf"
            echo "  4. ~/.config/valon/client.conf"
            echo "  5. /etc/valon/client.conf"
            exit 0
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Load configuration (or use environment variables as fallback)
if [[ -n "$CONFIG_FILE" && -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
else
    echo "Info: No config file found, using environment variables" >&2
fi

# Use environment variables as defaults
WG_INTERFACE="${WG_INTERFACE:-${VALON_INTERFACE:-wg0}}"
OWN_WG_IP="${OWN_WG_IP:-${VALON_WG_IP}}"
OWN_ALIAS="${OWN_ALIAS:-${VALON_ALIAS}}"
DISCOVERY_API="${DISCOVERY_API:-${VALON_API:-http://100.100.0.1:8053}}"
DISCOVERY_DNS="${DISCOVERY_DNS:-${VALON_DNS:-100.100.0.1}}"
DISCOVERY_PUBKEY="${DISCOVERY_PUBKEY:-${VALON_DISCOVERY_PUBKEY}}"
DNS_ZONE="${DNS_ZONE:-${VALON_DNS_ZONE:-valon.internal}}"
PING_COUNT="${PING_COUNT:-2}"
PING_TIMEOUT="${PING_TIMEOUT:-1}"
WG_PORT="${WG_PORT:-51820}"

# Check if running as root (only required for wg commands)
check_root() {
    if [[ $EUID -ne 0 ]]; then
        return 1
    fi
    return 0
}

# Validate configuration
if [[ -z "$WG_INTERFACE" ]]; then
    echo "Error: WG_INTERFACE not set (use config file or \$VALON_INTERFACE)" >&2
    exit 1
fi

# Check if WireGuard interface exists
if ! ip link show "$WG_INTERFACE" &> /dev/null; then
    echo "Error: WireGuard interface $WG_INTERFACE not found" >&2
    exit 1
fi

# Get own public key
OWN_PUBKEY=$(wg show "$WG_INTERFACE" public-key)
if [[ -z "$OWN_PUBKEY" ]]; then
    echo "Error: Could not get public key from $WG_INTERFACE" >&2
    exit 1
fi

# Get WireGuard listen port
WG_PORT=$(wg show "$WG_INTERFACE" listen-port 2>/dev/null)
if [[ -z "$WG_PORT" ]]; then
    echo "Error: Could not get listen port from $WG_INTERFACE" >&2
    exit 1
fi

# Get LAN endpoint (detect own LAN IP)
get_lan_endpoint() {
    # Try to detect LAN IP
    local lan_ip
    
    # Method 1: Get IP from default route interface
    lan_ip=$(ip route get 1 2>/dev/null | awk '{print $7; exit}')
    
    # Method 2: Fallback to first non-loopback IP
    if [[ -z "$lan_ip" ]]; then
        lan_ip=$(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | grep -v '^127\.' | head -n1)
    fi
    
    if [[ -n "$lan_ip" ]]; then
        echo "${lan_ip}:${WG_PORT}"
    fi
}

# Update own endpoint to Discovery
update_own_endpoint() {
    local lan_endpoint
    lan_endpoint=$(get_lan_endpoint)
    
    if [[ -z "$lan_endpoint" ]]; then
        echo "Warning: Could not detect LAN IP" >&2
        lan_endpoint=""
    fi
    
    echo "Updating own endpoint to Discovery Role..."
    echo "  Public key: ${OWN_PUBKEY:0:20}..."
    echo "  WireGuard IP: $OWN_WG_IP"
    echo "  Alias: $OWN_ALIAS"
    echo "  LAN endpoint: ${lan_endpoint:-none}"
    
    local response
    response=$(curl -s -X POST "$DISCOVERY_API/api/endpoint" \
        -H "Content-Type: application/json" \
        -d "{
            \"pubkey\": \"$OWN_PUBKEY\",
            \"lan_endpoint\": \"$lan_endpoint\",
            \"alias\": \"$OWN_ALIAS\"
        }")
    
    if echo "$response" | grep -q '"success":true'; then
        echo "  ✓ Updated successfully"
        return 0
    else
        echo "  ✗ Update failed: $response" >&2
        return 1
    fi
}

# Helper: Convert pubkey to DNS label
pubkey_to_label() {
    echo -n "$1" | base64 -d | base32 | tr '[:upper:]' '[:lower:]' | tr -d '='
}

# Helper: Test endpoint connectivity
test_endpoint() {
    local endpoint="$1"
    local ip port
    
    # Split IP:PORT
    ip="${endpoint%:*}"
    port="${endpoint##*:}"
    
    # Skip if empty or 0.0.0.0
    [[ -z "$ip" || "$ip" == "0.0.0.0" ]] && return 1
    
    # Ping test
    if ping -c "$PING_COUNT" -W "$PING_TIMEOUT" "$ip" &> /dev/null; then
        return 0
    else
        return 1
    fi
}

# Helper: Get endpoints for a peer
get_peer_endpoints() {
    local pubkey="$1"
    local label
    
    label=$(pubkey_to_label "$pubkey")
    
    # Query SRV records for endpoints with ports
    local lan_endpoint nat_endpoint lan_srv nat_srv
    
    # Get SRV records
    lan_srv=$(dig @"$DISCOVERY_DNS" +short "_wireguard._udp.$label.$DNS_ZONE" SRV 2>/dev/null | grep 'lan\.' | head -n1)
    nat_srv=$(dig @"$DISCOVERY_DNS" +short "_wireguard._udp.$label.$DNS_ZONE" SRV 2>/dev/null | grep 'nated\.' | head -n1)
    
    # Parse SRV: priority weight port target
    if [[ -n "$lan_srv" ]]; then
        local port target
        port=$(echo "$lan_srv" | awk '{print $3}')
        target=$(echo "$lan_srv" | awk '{print $4}' | sed 's/\.$//')
        
        # Resolve target to IP
        local ip
        ip=$(dig @"$DISCOVERY_DNS" +short "$target" A 2>/dev/null | head -n1)
        if [[ -n "$ip" ]]; then
            lan_endpoint="${ip}:${port}"
        fi
    fi
    
    if [[ -n "$nat_srv" ]]; then
        local port target
        port=$(echo "$nat_srv" | awk '{print $3}')
        target=$(echo "$nat_srv" | awk '{print $4}' | sed 's/\.$//')
        
        # Resolve target to IP
        local ip
        ip=$(dig @"$DISCOVERY_DNS" +short "$target" A 2>/dev/null | head -n1)
        if [[ -n "$ip" ]]; then
            nat_endpoint="${ip}:${port}"
        fi
    fi
    
    echo "$lan_endpoint|$nat_endpoint"
}

# Process a single peer
process_peer() {
    local pubkey="$1"
    local peer_name="${2:-unknown}"
    
    echo "Processing peer: $peer_name"
    echo "  Public key: ${pubkey:0:20}..."
    
    # Get endpoints
    local endpoints lan_endpoint nat_endpoint
    endpoints=$(get_peer_endpoints "$pubkey")
    lan_endpoint="${endpoints%|*}"
    nat_endpoint="${endpoints#*|}"
    
    echo "  LAN endpoint: ${lan_endpoint:-none}"
    echo "  NAT endpoint: ${nat_endpoint:-none}"
    
    # Test and select best endpoint
    local best_endpoint=""
    
    if [[ -n "$lan_endpoint" ]]; then
        echo "  Testing LAN endpoint..."
        if test_endpoint "$lan_endpoint"; then
            echo "    ✓ LAN reachable"
            best_endpoint="$lan_endpoint"
        else
            echo "    ✗ LAN unreachable"
        fi
    fi
    
    if [[ -z "$best_endpoint" && -n "$nat_endpoint" ]]; then
        echo "  Testing NAT endpoint..."
        if test_endpoint "$nat_endpoint"; then
            echo "    ✓ NAT reachable"
            best_endpoint="$nat_endpoint"
        else
            echo "    ✗ NAT unreachable"
        fi
    fi
    
    # Update WireGuard endpoint
    if [[ -n "$best_endpoint" ]]; then
        echo "  Setting endpoint: $best_endpoint"
        wg set "$WG_INTERFACE" peer "$pubkey" endpoint "$best_endpoint"
        echo "  ✓ Updated successfully"
    else
        echo "  ⚠ No reachable endpoint found"
    fi
    
    echo
}

# Main logic
echo "=== VALON Sync ==="
echo

# Step 1: Update own endpoint
update_own_endpoint
echo

# Step 2: Update peer endpoints
if [[ -n "$TARGET_PEER" ]]; then
    # Process single peer
    echo "Updating endpoint for specific peer..."
    echo
    process_peer "$TARGET_PEER"
else
    # Process all peers from WireGuard interface
    echo "Updating endpoints for all peers on $WG_INTERFACE..."
    echo
    
    peer_count=0
    while read -r pubkey rest; do
        # Skip interface line (first line)
        [[ "$pubkey" == "$OWN_PUBKEY" ]] && continue
        [[ -z "$pubkey" ]] && continue
        
        # Skip Discovery Role peer (check allowed-ips for 100.100.0.0/24)
        if [[ -n "$DISCOVERY_PUBKEY" && "$pubkey" == "$DISCOVERY_PUBKEY" ]]; then
            continue
        fi
        
        # Also skip if allowed-ips contains 100.100.0.0/24 (likely Discovery)
        allowed_ips=$(echo "$rest" | awk '{print $4}')
        if [[ "$allowed_ips" =~ 100\.100\.0\.0/24 || "$allowed_ips" =~ 100\.100\.0\.1/32 ]]; then
            echo "Skipping Discovery Role peer: ${pubkey:0:20}..."
            continue
        fi
        
        # Get peer name from DNS (optional, for display only)
        label=$(pubkey_to_label "$pubkey")
        peer_name="$label"
        
        process_peer "$pubkey" "$peer_name"
        ((peer_count++))
    done < <(wg show "$WG_INTERFACE" dump | tail -n +2)
    
    echo "✓ Processed $peer_count peer(s)"
fi

echo
echo "=== Sync completed ==="
